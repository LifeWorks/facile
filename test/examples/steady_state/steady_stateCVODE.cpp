//
// File generated by Facile version 0.53
//
// This code is adapted from the file "cvRoberts_dns.c", a usage example
// that is part of the the of the Sundials suite:
// * -----------------------------------------------------------------
// * Programmer(s): Scott D. Cohen, Alan C. Hindmarsh and
// *                Radu Serban @ LLNL
// * -----------------------------------------------------------------
//

#include <stdio.h>
#include <math.h>

// Custom header file
#include "steady_stateCVODE.h"

#define Ith(v,i)    NV_Ith_S(v,i)
#define IJth(A,i,j) DENSE_ELEM(A,i,j)

// These macros needed to properly handle discontinuities
#if defined(SUNDIALS_SINGLE_PRECISION)
#define DT_BEFORE(x) nextafterf((float)x,x/2.0)
#define DT_AFTER(x) nextafterf((float)x,x*2.0)
#elif defined(SUNDIALS_DOUBLE_PRECISION)
#define DT_BEFORE(x) nextafter((double)x,x/2.0)
#define DT_AFTER(x) nextafter((double)x,x*2.0)
#elif defined(SUNDIALS_EXTENDED_PRECISION)
#define DT_BEFORE(x) nextafterl((long double)x,x/2.0)
#define DT_AFTER(x) nextafterl((long double)x,x*2.0)
#endif

// Private function to check function return values

static int check_flag(void *flagvalue, char *funcname, int opt);

// Private function to setup events
static int setup_next_event(void *cvode_mem, realtype t, realtype tf,
                            unsigned int &ode_event_index,
                            unsigned int num_ode_events,
                            std::vector<realtype> &ode_events,
                            std::vector<realtype> &ode_events_minus_dt,
                            int &steady_state_flag, realtype &ss_timeout
                           );

// Private functions to output results

static void StoreOutput(std::vector<realtype> &T,
                        std::vector<realtype> &Y,
                        realtype t, N_Vector y);

static void PrintOutput(realtype t, N_Vector y);

// Private function to print final statistics

static void PrintFinalStats(void *cvode_mem);

// User-defined model functions by the Solver

static int f_dydt(realtype t, N_Vector y, N_Vector ydot, void * user_data);

static int f_jac(int N, realtype t,
                 N_Vector y, N_Vector fy, DlsMat J, void * user_data,
                 N_Vector tmp1, N_Vector tmp2, N_Vector tmp3);

// Constants and functions that may appear in user-defined model functions
static const realtype pi = atan(1.0)*4.0;

// Octave-style square() function -- (duty cycle between 0 and 1)
static realtype square(realtype t, realtype duty) {
  realtype r;

  if(t < 0) {
    realtype shift = ceil(-t / (2.0 * pi));
    t = t + shift * 2 * pi;
  }

  realtype phase = fmod(t, 2*pi);

  if (phase < 2*pi * duty) {
    r = +1;
  } else {
    r = -1;
  }
  return r;
}

static realtype square(realtype t) {
  realtype r;
  realtype duty = 0.5;

  if(t < 0) {
    realtype shift = ceil(-t / (2.0 * pi));
    t = t + shift * 2 * pi;
  }

  realtype phase = fmod(t, 2*pi);

  if (phase < 2*pi * duty) {
    r = +1;
  } else {
    r = -1;
  }
  return r;
}


// Main Program

int cvode_sim_steady_state(double *ivalues, double *ode_rate_constants,
                                  std::vector<realtype> &tv,
                                  std::vector<realtype> &aT,
                                  std::vector<realtype> &aY,
                                  std::vector<realtype> &ode_options,
                                  std::vector<realtype> &ode_events,
                                  std::vector<int>      &event_flags,
                                  std::vector<realtype> &event_times
                                 ) {

  if (tv.size() < 2) {
    printf("ERROR: invalid time vector (tv)\n");
    printf("==> tv.size() = : %d\n",tv.size());
    return(1);
  }

  realtype t0 = tv[0];
  N_Vector y = NULL;

  void *cvode_mem = NULL;

  int flag;

  // Create serial vector of length NEQ for I.C.
  y = N_VNew_Serial(NEQ);
  if (check_flag((void *)y, (char*)"N_VNew_Serial", 0)) return(1);

  // initial values (free nodes only)
  Ith(y,0) = ivalues[0]; // X
  Ith(y,1) = ivalues[1]; // Y
  Ith(y,2) = ivalues[2]; // Z

  // set absolute and relative integration tolerances
  realtype reltol = RCONST(ode_options[ODE_OPTION_RELTOL]);
  N_Vector abstol = N_VNew_Serial(NEQ);
  if (check_flag((void *)abstol, (char*)"N_VNew_Serial", 0)) return(1);
  for (int i=0; i<NEQ; i++) {
    Ith(abstol,i) = RCONST(ode_options[ODE_OPTION_ABSTOL]);
  }

  // set steady-state timescale and tolerances
  realtype SS_timescale = ode_options[ODE_OPTION_SS_TIMESCALE];
  realtype SS_RelTol    = ode_options[ODE_OPTION_SS_RELTOL];
  realtype SS_AbsTol    = ode_options[ODE_OPTION_SS_ABSTOL];


  // Call CVodeCreate to create the solver memory and specify the
  // Backward Differentiation Formula and the use of a Newton iteration
  cvode_mem = CVodeCreate(CV_BDF, CV_NEWTON);
  if (check_flag((void *)cvode_mem, (char*)"CVodeCreate", 0)) return(1);
  
  // Call CVodeInit to initialize the integrator memory and specify the
  // user's right hand side function in y'=f(t,y), the inital time t0, and
  // the initial dependent variable vector y.
  flag = CVodeInit(cvode_mem, f_dydt, t0, y);
  if (check_flag(&flag, (char*)"CVodeInit", 1)) return(1);

  // Call CVodeSVtolerances to specify the scalar relative tolerance
  // and vector absolute tolerances
  flag = CVodeSVtolerances(cvode_mem, reltol, abstol);
  if (check_flag(&flag, (char*)"CVodeSVtolerances", 1)) return(1);

  // Call CVodeSetUserData to specify rate constants
  void * user_data[3];
  user_data[0] = ode_rate_constants;
  user_data[1] = &event_flags;
  user_data[2] = &event_times;
  flag = CVodeSetUserData(cvode_mem, user_data);
  if (check_flag(&flag, (char*)"CVodeSetUserData", 1)) return(1);

  // Call CVDense to specify the CVDENSE dense linear solver
  flag = CVDense(cvode_mem, NEQ);
  if (check_flag(&flag, (char*)"CVDense", 1)) return(1);

  // Set the Jacobian routine
  flag = CVDlsSetDenseJacFn(cvode_mem, f_jac);
  if (check_flag(&flag, (char*)"CVDlsSetDenseJacFn", 1)) return(1);

  // Set misc ODE solver options
  if (ode_options[ODE_OPTION_INITSTEP] >= 0.0) {
    flag = CVodeSetInitStep(cvode_mem, ode_options[ODE_OPTION_INITSTEP]);
    if (check_flag(&flag, (char*)"CVodeSetInitStep", 1)) return(1);
  }
  if (ode_options[ODE_OPTION_MINSTEP] >= 0.0) {
    flag = CVodeSetMinStep(cvode_mem, ode_options[ODE_OPTION_MINSTEP]);
    if (check_flag(&flag, (char*)"CVodeSetMinStep", 1)) return(1);
  }
  if (ode_options[ODE_OPTION_MAXSTEP] >= 0.0) {
    flag = CVodeSetMaxStep(cvode_mem, ode_options[ODE_OPTION_MAXSTEP]);
    if (check_flag(&flag, (char*)"CVodeSetMaxStep", 1)) return(1);
  }

  // Initialize ODE events vector
  unsigned int num_ode_events = ode_events.size();
  event_flags.resize(num_ode_events);
  event_times.resize(num_ode_events);
  std::vector<realtype> ode_events_minus_dt(num_ode_events);
  for(unsigned int i; i < num_ode_events; i++) {
    event_flags[i] = 0;
    event_times[i] = ode_events[i];
    if (ode_events[i] > 0)
      // absolute-time event (discontinuity)
      ode_events_minus_dt[i] = DT_BEFORE(ode_events[i]);
    else if (ode_events[i] < 0)
      // relative-time event
      ode_events_minus_dt[i] = 0;
    else
      // steady-state event
      ode_events_minus_dt[i] = 0;
  }

  // Setup mode and storage vectors
  unsigned int tv_size = tv.size();
  int cvode_mode = tv_size > 2 ? CV_NORMAL : CV_ONE_STEP;
  unsigned int num_samples = (cvode_mode == CV_NORMAL) ? tv_size : 100;
  aT.resize(0); aT.reserve(num_samples);
  aY.resize(0); aY.reserve((num_samples)*NEQ);

  // Initial and final time
  realtype t = t0;
  realtype tf = tv[tv_size-1];

  // Setup first event if any
  unsigned int ode_event_index = 0;
  int steady_state_flag = 0;
  realtype ss_timeout = 0;
  if (setup_next_event(cvode_mem, t0, tf,
                       ode_event_index,num_ode_events,
                       ode_events,ode_events_minus_dt,
                       steady_state_flag,ss_timeout)) return 1;

  // Print output at initial time
  //PrintOutput(t, y);
  StoreOutput(aT, aY, t, y);

  // Main loop: call CVode, output results, manage events and test for errors.

  unsigned int i_sample = 1;
  realtype tout = (cvode_mode == CV_NORMAL) ? tv[i_sample] : tf / realtype(100.0);

  while(1) {
    // call solver
    flag = CVode(cvode_mem, tout, y, &t, cvode_mode);
    if (check_flag(&flag, (char*)"CVode", 1)) break;

    // determine next step
    if (steady_state_flag == 0 && flag == CV_SUCCESS) {
//printf("yyy1 t=%.40f steady_state_flag=%d\n",t, steady_state_flag);
      //PrintOutput(t, y);
      StoreOutput(aT, aY, t, y);
      if (cvode_mode == CV_NORMAL) {
        i_sample++;
        tout = tv[i_sample];
      } else {
        tout = 0.0;
      }
    } else if (steady_state_flag == 0 && flag == CV_TSTOP_RETURN) {
//printf("yyy2 t=%.40f steady_state_flag=%d\n",t, steady_state_flag);
      // Check that we stopped at expected time
      if (t != ode_events_minus_dt[ode_event_index]) { // should always be equal
        printf("ERROR: unexpected integrator CV_TSTOP_RETURN\n");
        break;
      }

      // Output value at (event-dt) only if solver-defined steps
      if (cvode_mode == CV_ONE_STEP) {
        //PrintOutput(t, y);
        StoreOutput(aT, aY, t, y);
      }

      // Advance time to the discontinuity, extend and output y
      t = ode_events[ode_event_index];
      printf("ODE EVENT at t=%.20f\n",t);

      // Ouput value at event time if solver-defined steps or if on user-defined sample point
      if (cvode_mode == CV_ONE_STEP || (cvode_mode == CV_NORMAL && t == tout)) {
        //PrintOutput(t, y);
        StoreOutput(aT, aY, t, y);
        if (cvode_mode == CV_NORMAL) {
          // user-defined sampling, so move to next sample point
          i_sample++;
          tout = tv[i_sample];
        } else {
          // CV_ONE_STEP mode, need estimate of next output time
          tout = t + (tf - t0)/100.0;
        }
      }

      // Call CVodeReInit to re-initialize the integrator
      flag = CVodeReInit(cvode_mem, t, y);
      if (check_flag(&flag, (char*)"CVodeReInit", 1)) return(1);
      if (cvode_mode == CV_ONE_STEP) tout = t + (tf - t0)/100.0; // estimate output time

      // Update event_flags
      event_flags[ode_event_index] = 1;

      // Update event_times now that event time is known
      event_times[ode_event_index] = t;

      // Setup next event
      ode_event_index++;
      if (setup_next_event(cvode_mem, t, tf,
                           ode_event_index,num_ode_events,
                           ode_events,ode_events_minus_dt,
                           steady_state_flag,ss_timeout)) return 1;

    } else if (steady_state_flag == 1) {

      if (flag == CV_SUCCESS) {
        // steady-state has *NOT* timed out
//printf("yyy3 t=%.40f steady_state_flag=%d\n",t, steady_state_flag);

        //PrintOutput(t, y);
        StoreOutput(aT, aY, t, y);
        if (cvode_mode == CV_NORMAL) {
          i_sample++;
          tout = tv[i_sample];
        } else {
          tout = 0.0;
        }

        // check for steady-state condition
        int steady_state_reached = 1;
        unsigned int before_last_index = aT.size() - 2;
        realtype delta_t = t - aT[before_last_index];
        unsigned int y_offset = before_last_index * NEQ;
        for (unsigned int i = 0; i < NEQ; i++) {
          // SS stopping condition:
          //   dy/dt * SS_timescale < SS_RelTol * max(abs(y), SS_AbsTol)
          realtype y_last = Ith(y,i);
          realtype delta_y = fabs((y_last - aY[y_offset + i]) * SS_timescale / delta_t);
          realtype abs_y_last = fabs(y_last);
          if (abs_y_last < SS_AbsTol) abs_y_last = SS_AbsTol;
          realtype delta_y_threshold = SS_RelTol * (abs_y_last > SS_AbsTol ? abs_y_last : SS_AbsTol);
          if (delta_y >= delta_y_threshold) {
            steady_state_reached = 0;
          }
        }

        if (steady_state_reached == 1) {
          printf("STEADY-STATE REACHED AT t=%.20f\n", t);

          // reset steady_state_flag
          steady_state_flag = 0;

          // Update event_flags
          event_flags[ode_event_index] = 1;

          // Update event_times now that event time is known
          event_times[ode_event_index] = t;

          // Stop if steady-state event was the last event
          if (ode_event_index == num_ode_events - 1) break;

          // Call CVodeReInit to re-initialize the integrator
          flag = CVodeReInit(cvode_mem, t, y);
          if (check_flag(&flag, (char*)"CVodeReInit", 1)) return(1);
          if (cvode_mode == CV_ONE_STEP) tout = t + (tf - t0)/100.0; // estimate output time

          // Setup next event
          ode_event_index++;
          if (setup_next_event(cvode_mem, t, tf,
                               ode_event_index,num_ode_events,
                               ode_events,ode_events_minus_dt,
                               steady_state_flag,ss_timeout)) return 1;

        }

      } else if (flag == CV_TSTOP_RETURN) {
        // steady-state *HAS* timed out
//printf("yyy4 t=%.40f steady_state_flag=%d\n",t, steady_state_flag);

        // Check that we stopped at expected time
        if (t != ss_timeout) { // should always be equal
          printf("ERROR: unexpected integrator CV_TSTOP_RETURN\n");
          break;
        }

        // Advance time to the actual timeout value
        t = ss_timeout = DT_AFTER(ss_timeout);

        printf("STEADY-STATE TIMED-OUT AT t=%.20f\n", t);
//printf("yyy5 t=%.40f steady_state_flag=%d\n",t, steady_state_flag);

        // Ouput value at event time if solver-defined steps or if on user-defined sample point
        if (cvode_mode == CV_ONE_STEP || (cvode_mode == CV_NORMAL && t == tout)) {
          //PrintOutput(t, y);
          StoreOutput(aT, aY, t, y);
          if (cvode_mode == CV_NORMAL) {
            // user-defined sampling, so move to next sample point
            i_sample++;
            tout = tv[i_sample];
          } else {
            // CV_ONE_STEP mode, need estimate of next output time
            tout = t + (tf - t0)/100.0;
          }
        }

        // reset steady_state_flag
        steady_state_flag = 0;

        // Update event_flags
        event_flags[ode_event_index] = 1;

        // Update event_times now that event time is known
        event_times[ode_event_index] = t;

        // Stop if we timed out on tf
        if (t >= tf) break;

        // We timed-out, so advance to event corresponding to ss_timeout if any
        while(ode_event_index < num_ode_events &&
              ode_events[ode_event_index] != ss_timeout) {
          ode_event_index++;
        }

        // Call CVodeReInit to re-initialize the integrator
        flag = CVodeReInit(cvode_mem, t, y);
        if (check_flag(&flag, (char*)"CVodeReInit", 1)) return(1);
        if (cvode_mode == CV_ONE_STEP) tout = t + (tf - t0)/100.0; // estimate output time

        // Setup next event
        ode_event_index++;
        if (setup_next_event(cvode_mem, t, tf,
                             ode_event_index,num_ode_events,
                             ode_events,ode_events_minus_dt,
                             steady_state_flag,ss_timeout)) return 1;

      }

    } else {
      printf("ERROR: unexpected condition\n");
      break;
    }

    // Stopping condition
    if (t >= tf) break;
  }

  // Print some final statistics
  PrintFinalStats(cvode_mem);

  // Free y and abstol vectors
  N_VDestroy_Serial(y);
  N_VDestroy_Serial(abstol);

  // Free integrator memory
  CVodeFree(&cvode_mem);

  return(0);
}

// Private helper functions
static int setup_next_event(void *cvode_mem, realtype t, realtype tf,
                            unsigned int &ode_event_index,
                            unsigned int num_ode_events,
                            std::vector<realtype> &ode_events,
                            std::vector<realtype> &ode_events_minus_dt,
                            int &steady_state_flag, realtype &ss_timeout
                           ) {
  int flag;
  ss_timeout = 0;

  if ((ode_event_index < num_ode_events) && (ode_events[ode_event_index] > 0)) {
    // positive, absolute event time
    realtype next_event = ode_events_minus_dt[ode_event_index];
    flag = CVodeSetStopTime(cvode_mem, next_event);
    if (check_flag(&flag, (char*)"CVodeSetStopTime", 1)) return(1);
  } else if ((ode_event_index < num_ode_events) && (ode_events[ode_event_index] < 0)) {
    // negative event time, so the next event time is relative to current time
    ode_events[ode_event_index] = t - ode_events[ode_event_index]; // update event time now that it is known
    ode_events_minus_dt[ode_event_index] = DT_BEFORE(ode_events[ode_event_index]);
    realtype next_event = ode_events_minus_dt[ode_event_index];
    flag = CVodeSetStopTime(cvode_mem, next_event);
    if (check_flag(&flag, (char*)"CVodeSetStopTime", 1)) return(1);
  } else if ((ode_event_index < num_ode_events) && (ode_events[ode_event_index] == 0)) {
    // next event is steady-state
    steady_state_flag = 1;

    // compute time-out
    for (unsigned int i = ode_event_index + 1; i < num_ode_events; i++) {
      if (ode_events[i] > 0) {
        ss_timeout = ode_events[i];
        break;
      }
    }
    if (ss_timeout == 0) ss_timeout = tf;
    ss_timeout = DT_BEFORE(ss_timeout);
    // don't let integrator go past steady-state timeout
    flag = CVodeSetStopTime(cvode_mem, ss_timeout);
    if (check_flag(&flag, (char*)"CVodeSetStopTime", 1)) return(1);
  } else {
    // no events left
    flag = CVodeSetStopTime(cvode_mem, 2.0*tf);
    if (check_flag(&flag, (char*)"CVodeSetStopTime", 1)) return(1);
  }

  return 0;
}



static void StoreOutput(std::vector<realtype> &aT,
                        std::vector<realtype> &aY,
                        realtype t, N_Vector y) {
  // store t
  aT.push_back(t);

  // store y(t)
  realtype *y_ptr = &(Ith(y,0));
  for(int i=0; i < NEQ; i++) {
    aY.push_back(y_ptr[i]);
  }
}

static void PrintOutput(realtype t, N_Vector y) {
  printf("At t = %0.20e      y[] = ",t);
  for (unsigned int i=0; i < NEQ; i++) {
    printf("%.20e  ", Ith(y,i));
  }
  printf("\n");
  return;
}

int cvode_sim_print_output(std::vector<realtype> &aT,
                           std::vector<realtype> &aY) {
  unsigned int num_samples = aT.size();
  for(unsigned int i = 0; i < num_samples; i++) {
    printf("At t = %0.20e      y[] = ",aT[i]);
    for (unsigned int j=0; j < NEQ; j++) {
      printf("%.20e  ", aY[i*NEQ + j]);
    }
    printf("\n");
  }
}

// Get and print some final statistics

static void PrintFinalStats(void *cvode_mem) {
  long int nst, nfe, nsetups, nje, nfeLS, nni, ncfn, netf, nge;
  int flag;

  flag = CVodeGetNumSteps(cvode_mem, &nst);
  check_flag(&flag, (char*)"CVodeGetNumSteps", 1);
  flag = CVodeGetNumRhsEvals(cvode_mem, &nfe);
  check_flag(&flag, (char*)"CVodeGetNumRhsEvals", 1);
  flag = CVodeGetNumLinSolvSetups(cvode_mem, &nsetups);
  check_flag(&flag, (char*)"CVodeGetNumLinSolvSetups", 1);
  flag = CVodeGetNumErrTestFails(cvode_mem, &netf);
  check_flag(&flag, (char*)"CVodeGetNumErrTestFails", 1);
  flag = CVodeGetNumNonlinSolvIters(cvode_mem, &nni);
  check_flag(&flag, (char*)"CVodeGetNumNonlinSolvIters", 1);
  flag = CVodeGetNumNonlinSolvConvFails(cvode_mem, &ncfn);
  check_flag(&flag, (char*)"CVodeGetNumNonlinSolvConvFails", 1);

  flag = CVDlsGetNumJacEvals(cvode_mem, &nje);
  check_flag(&flag, (char*)"CVDlsGetNumJacEvals", 1);
  flag = CVDlsGetNumRhsEvals(cvode_mem, &nfeLS);
  check_flag(&flag, (char*)"CVDlsGetNumRhsEvals", 1);

  flag = CVodeGetNumGEvals(cvode_mem, &nge);
  check_flag(&flag, (char*)"CVodeGetNumGEvals", 1);

  printf("\nFinal Statistics:\n");
  printf("nst = %-6ld nfe  = %-6ld nsetups = %-6ld nfeLS = %-6ld nje = %ld\n",
	 nst, nfe, nsetups, nfeLS, nje);
  printf("nni = %-6ld ncfn = %-6ld netf = %-6ld nge = %ld\n \n",
	 nni, ncfn, netf, nge);
}

//
// Check function return value...
//   opt == 0 means SUNDIALS function allocates memory so check if
//            returned NULL pointer
//   opt == 1 means SUNDIALS function returns a flag so check if
//            flag >= 0
//   opt == 2 means function allocates memory so check if returned
//            NULL pointer 
//

static int check_flag(void *flagvalue, char *funcname, int opt) {
  int *errflag;

  /* Check if SUNDIALS function returned NULL pointer - no memory allocated */
  if (opt == 0 && flagvalue == NULL) {
    fprintf(stderr, "\nSUNDIALS_ERROR: %s() failed - returned NULL pointer\n\n",
	    funcname);
    return(1); }

  /* Check if flag < 0 */
  else if (opt == 1) {
    errflag = (int *) flagvalue;
    if (*errflag < 0) {
      fprintf(stderr, "\nSUNDIALS_ERROR: %s() failed with flag = %d\n\n",
	      funcname, *errflag);
      return(1); }}

  /* Check if function returned NULL pointer - no memory allocated */
  else if (opt == 2 && flagvalue == NULL) {
    fprintf(stderr, "\nMEMORY_ERROR: %s() failed - returned NULL pointer\n\n",
	    funcname);
    return(1); }

  return(0);
}

static int f_dydt(realtype t, N_Vector y, N_Vector ydot, void * user_data) {
//    printf("f_dydt call at t=%.20f\n",t);

    void** user_data_array = (void**) user_data;

    realtype *ode_rate_constants       = (realtype *)                user_data_array[0];
    std::vector<int> &event_flags      = *((std::vector<int> *)      user_data_array[1]);
    std::vector<realtype> &event_times = *((std::vector<realtype> *) user_data_array[2]);

    // state vector to node mapping
    realtype X = Ith(y,0);
    realtype Y = Ith(y,1);
    realtype Z = Ith(y,2);

    // rate constants and constant expressions
    realtype k_sinkx = ode_rate_constants[0];
    realtype k_sinky = ode_rate_constants[1];
    realtype k_sinkz = ode_rate_constants[2];



    // dynamic rate expressions
    realtype k_srcx = 2*(t>=50 && ~event_flags[3 - 1]);
    realtype k_srcy = 3*(event_flags[4 - 1]);
    realtype k_srcz = 4*(event_flags[6 - 1]);

    // differential equations for independent species
    Ith(ydot,0) =  + k_srcx - k_sinkx*X;
    Ith(ydot,1) =  + k_srcy - k_sinky*Y;
    Ith(ydot,2) =  + k_srcz - k_sinkz*Z;

    return (0);
}

static int f_jac(int N, realtype t,
                 N_Vector y, N_Vector fy, DlsMat J, void * user_data,
                 N_Vector tmp1, N_Vector tmp2, N_Vector tmp3) {

    void** user_data_array = (void**) user_data;

    realtype *ode_rate_constants       = (realtype *)                user_data_array[0];
    std::vector<int> &event_flags      = *((std::vector<int> *)      user_data_array[1]);
    std::vector<realtype> &event_times = *((std::vector<realtype> *) user_data_array[2]);

    // state vector to node mapping
    realtype X = Ith(y,0);
    realtype Y = Ith(y,1);
    realtype Z = Ith(y,2);

    // rate constants and constant expressions
    realtype k_sinkx = ode_rate_constants[0];
    realtype k_sinky = ode_rate_constants[1];
    realtype k_sinkz = ode_rate_constants[2];



    // dynamic rate expressions
    realtype k_srcx = 2*(t>=50 && ~event_flags[3 - 1]);
    realtype k_srcy = 3*(event_flags[4 - 1]);
    realtype k_srcz = 4*(event_flags[6 - 1]);

    // jacobian equations for independent species
    for (unsigned int i=0; i < 3; i++) {
        for (unsigned j=0; j < 3; j++) {
            IJth(J,i,j) = 0.0;
        }
    }
    IJth(J,0,0) =  - k_sinkx;
    IJth(J,1,1) =  - k_sinky;
    IJth(J,2,2) =  - k_sinkz;

    return (0);
}
